+ "use strict"; 严格模式

+ try catch 如果try中的代码报错了，那么就会立即执行catch中的代码；不会影响下面的代码执行  如果不报错，那么就不走catch

+ alert 的结果都要加''，弹出的值都是字符串
  
+ alert alert会在浏览器描绘dom之前执行
  
+ 等号赋值都是三步 1.创建变量 2.创建值 3.关联
  
+ 属性值一定得是数据类型的一种，不然就报错
  
+ console.log(name) 不报错，虽然name不是数据类型的一种但是windom中有个name的属性名，属性值是空字符串
  
+ DOM 树--> CSS树---> render树 --> pait(描绘)
  
+ debugger 断点：让代码执行停止到这一行
  
+ 在代码执行的过程中，遇到函数直接跳过，因为在变量提升时函数已经赋值了
  
+ 当函数执行的时候，才会对函数体中的代码进行变量提升
  
+ 支持es6的浏览器，会把这个if的大阔号解析成一个块级作用域；
  
+ 在全局作用域下定义的函数，也会给window新增键值对；属性名是函数名，属性值时函数的空间地址；
  
+ 如果属性的属性值是一个自执行函数，那么当代码以键值对储存的时候(当代码执行到这一行时，自执行函数就会运行)，并且把自执行函数的执行结果赋值给属性名
  
+ 如果变量名重名，不再进行重复声明，但是要重新赋值
  
+ function add(){}这种写法叫做函数声明      var add=function(){}这种写法叫做函数表达式      function(){}这种是匿名函数  
    
+ 函数声明和匿名函数自执行需要加()或+或-或!
  
+ Object.keys()  :将对象中所有的属性名放到一个数组中

+ Object.create() :将对象中所有的属性值放到一个数组中
  
+ 
```
num = 1;
let a = num++;
console.log(a); //1
//a=1  num=2  先赋值再运算
```

+ let 声明变量在for循环中，每一轮循环都会形成一个自作用域(块级作用域)，

+ 函数每执行一次，都会形成一个新的栈内存；

+ setAttribute(attributename,attributename) 方法添加指定的属性，并为其赋指定的值。
    属性可以是自定义的属性，如果这个指定的属性已存在，则仅设置/更改值

+ getAttribute(attributename);获取某个属性的值；返回值为string类型
    注：attributename，value都是字符串类型

**块级作用域** {和}之间会形成块级作用域(ES5中只有全局作用域和私有作用域，这导致很多场景不合理)
> 为什么需要块级作用域(如果没有块级作用域会发生什么)
  1. 用来计数的循环变量泄露为全局变量
    ```
    var s = "hello";
    for (var i = 0;i < s.length; i++){
        //将var改为let可以避免i变成全局变量
        console.log(s[i]); 
    }
    console.log(i);//5

    ```

> 块级作用域  (1.当代码执行到这一行就会形成 2.进入块级作用域首先对函数进行赋值 3.代码从上到下进行赋值)  
  1. let实际上为JavaScript新增了块级作用域
    ```
    function f1(){
        let n = 5;
        if(true){
            let n = 10;
        }
        console.log(n);//5
    }
    解析：上面函数有两个代码块，都声明了变量n，运行后输出5。表明外层代码块不受内层代码块的影响。但如果使用var定义变量n，最后输出的值就是10
    ```

  2. ES6允许块级作用域的任意嵌套
    ```
    {{{{
    {let greet = "hello woeld"}
    console.log(greet);//报错
    }}}};
    上面的代码使用了一个5层的块级作用域。但是外层作用域无法读取内层作用域的变量
    ```

  3. 内层作用域可以定义外层作用域的同名变量
    ```
    {{{{
    let greet = "hello world";
    {let greet = "hello"}
    }}}}
    如果最里面的变量用var会改变外面变量的值用let就不会
    ```

  4. 块级作用域也可以形成闭包的效果
    ```
    var i = 100;
    for (let i = 0; i < 10; i++) {
        (function fn() {
            return i;
        })()
        console.log(i);
    }
    console.log(i);
    内部的函数可以获取for的变量i，可以避免内部变量受外界变量干扰
    ```

> 函数声明
  1. ES6引入块级作用域，明确允许在块级作用域之中声明函数。ES6规定，在块级作用域之中，函数声明类似与let，在块级作用域之外不可引用

  2. 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式的形式而不是函数声明语句
 
+ 一个函数的参数是另一个函数的执行，那么就说另一个函数(执行的函数)是函数的回调函数

+ this不能放在等号左边

+ jquery的源码的外层就是采用了这种高级单例的模式；

+ 用取整要加10进制  parseInt(a,radix:10);

+  <textarea type='text' id="num1">输入数字</textarea>  实时获取文字方法  名字.value

+ 在全局作用域中存在n，windom中也存在n，会先找全局，再找windom

+ eval可以将字符串去掉，让里面的表达式运行